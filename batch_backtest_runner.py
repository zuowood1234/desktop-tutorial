import pandas as pd
import subprocess
import os
import sys
from datetime import datetime

# ç›®æ ‡è‚¡ç¥¨æ±  (10åªä»£è¡¨æ€§è‚¡ç¥¨)
STOCK_POOL = {
    "000001": "å¹³å®‰é“¶è¡Œ",
    "600519": "è´µå·èŒ…å°",
    "300750": "å®å¾·æ—¶ä»£",
    "002594": "æ¯”äºšè¿ª",
    "601126": "å››æ–¹è‚¡ä»½",
    "002050": "ä¸‰èŠ±æ™ºæ§",
    "601318": "ä¸­å›½å¹³å®‰",
    "000021": "æ·±ç§‘æŠ€",
    "600030": "ä¸­ä¿¡è¯åˆ¸",
    "300059": "ä¸œæ–¹è´¢å¯Œ"
}

START_DATE = "2025-01-01"
END_DATE = "2025-12-31"

results = []

print(f"ğŸš€ å¼€å§‹æ‰¹é‡å›æµ‹: {len(STOCK_POOL)} åªè‚¡ç¥¨ | {START_DATE} ~ {END_DATE}")
print("="*80)

for code, name in STOCK_POOL.items():
    print(f"\nğŸ”„ æ­£åœ¨åˆ†æ: {name} ({code})...")
    
    # Run V1 (Technical) using subprocess to simulate command line execution efficiently
    # Using python3 interpreter
    try:
        # V1 Backtest
        cmd_v1 = [sys.executable, "backtest_engine.py", code, "--start", START_DATE, "--end", END_DATE]
        # Calculate Benchmark (Buy & Hold) from V1 data usually, but here we run full logic
        # We capture output to parse final asset
        # To simplify, we will modify the engines to return JSON or save CSV, 
        # but for this runner we will parsing CSVs generated by engines.
        
        subprocess.run(cmd_v1, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Read V1 Result
        v1_file = f"backtest_v1_{code}.csv"
        df_v1 = pd.read_csv(v1_file)
        
        # åˆå§‹èµ„é‡‘
        initial_capital = 100000
        
        # V1 Final Return
        v1_final = df_v1.iloc[-1]['æ€»èµ„äº§']
        v1_roi = (v1_final - initial_capital) / initial_capital * 100
        
        # Benchmark (Buy & Hold) Calculation
        # Assuming the first close is buy price, last close is sell price
        first_close = df_v1.iloc[0]['æ”¶ç›˜']
        last_close = df_v1.iloc[-1]['æ”¶ç›˜']
        benchmark_roi = (last_close - first_close) / first_close * 100
        
        # V2 Backtest
        cmd_v2 = [sys.executable, "backtest_engine_v2.py", code, "--start", START_DATE, "--end", END_DATE]
        subprocess.run(cmd_v2, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Read V2 Result
        v2_file = f"backtest_v2_{code}.csv"
        df_v2 = pd.read_csv(v2_file)
        v2_final = df_v2.iloc[-1]['æ€»èµ„äº§']
        v2_roi = (v2_final - initial_capital) / initial_capital * 100
        
        # Determine Winner
        if v1_roi > v2_roi and v1_roi > benchmark_roi:
            winner = "V1 (æ¿€è¿›)"
        elif v2_roi > v1_roi and v2_roi > benchmark_roi:
            winner = "V2 (ç¨³å¥)"
        elif benchmark_roi > v1_roi and benchmark_roi > v2_roi:
            winner = "åŸºå‡† (æŒæœ‰)"
        else:
            winner = "å¹³å±€"
            
        print(f"   ğŸ“Š ç»“æœ: V1={v1_roi:.2f}% | V2={v2_roi:.2f}% | åŸºå‡†={benchmark_roi:.2f}%")
        
        results.append({
            "ä»£ç ": code,
            "åç§°": name,
            "åŸºå‡†æ¶¨å¹…": f"{benchmark_roi:.2f}%",
            "V1æ”¶ç›Š (MA5)": f"{v1_roi:.2f}%",
            "V2æ”¶ç›Š (MA10)": f"{v2_roi:.2f}%",
            "è¶…é¢æ”¶ç›Š(V1 vs åŸºå‡†)": f"{v1_roi - benchmark_roi:.2f}%",
            "è¶…é¢æ”¶ç›Š(V2 vs åŸºå‡†)": f"{v2_roi - benchmark_roi:.2f}%",
            "èƒœè€…": winner
        })

    except Exception as e:
        print(f"âŒ åˆ†æ {name} å¤±è´¥: {e}")

# Generate Summary Report
print("\n" + "="*80)
print("ğŸ† 2025å¹´åº¦ ç­–ç•¥å›æµ‹ç»ˆææˆ˜æŠ¥")
print("="*80)

df_summary = pd.DataFrame(results)
print(df_summary.to_markdown(index=False))

# Save
df_summary.to_csv("backtest_summary_2025.csv", index=False, encoding='utf-8-sig')
print(f"\nâœ… è¯¦ç»†æŠ¥è¡¨å·²ä¿å­˜: backtest_summary_2025.csv")
